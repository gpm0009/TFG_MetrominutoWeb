 # distance_matrix(client, origins, destinations,
    #                 mode=None, language=None, avoid=None, units=None,
    #                 departure_time=None, arrival_time=None, transit_mode=None,
    #                 transit_routing_preference=None, traffic_model=None, region=None);


# Burgos = 42.34, -3.69
    # Medina = 42.93, -3.51
    # Villar = 42.9396796, -3.5805516
    # Espinosa = 43.0792415, -3.5550065
    # origins_prueba = [[42.34, -3.69], [42.93, -3.51], [42.9396796, -3.5805516], [43.0792415, -3.5550065]]
    # destinations_prueba = [[42.34, -3.69], [42.93, -3.51], [42.9396796, -3.5805516], [43.0792415, -3.5550065]]
    # matrix = gmaps.distance_matrix(origins_prueba, destinations_prueba)

# graph.add_node('Burgos', pos=(42.34, 3.69))
    # graph.add_node('Medina', pos=(42.93, 3.51))
    # graph.add_node('Villar', pos=(42.93, 3.58))
    # graph.add_node('Espinosa', pos=(43.07, 3.55))
    #
    # graph.add_edge('Burgos', 'Medina', weight=dista[0][1])
    # graph.add_edge('Medina', 'Villar', weight=dista[1][2])
    # graph.add_edge('Villar', 'Espinosa', weight=dista[2][3])
    # graph.add_edge('Espinosa', 'Burgos', weight=dista[3][0])


# edge_list = list(mst)  # make a list of the edges
    # print(edge_list)
    # for z in range(0, edge_list.__len__()):
    #     min_graph.add_edge(edge_list[z][0], edge_list[z][1], weight=edge_list[z][2]['weight'])
    #nx.draw(min_graph, pos=nx.get_node_attributes(graph, 'pos'), with_labels=True)


 # mst = nx.minimum_spanning_tree(graph, weight='weight')
    # nx.draw(mst, pos=nx.get_node_attributes(graph, 'pos'), with_labels=True)

    # mst = nx.minimum_spanning_edges(graph, weight='weight', data=True)
    # edge_list = list(mst)  # make a list of the edges
    # prueba = sample(edge_list, k=2)
    # for z in range(0, edge_list.__len__()):
    #     min_graph.add_edge(edge_list[z][0], edge_list[z][1], weight=edge_list[z][2]['weight'])
    # nx.draw(min_graph, pos=nx.get_node_attributes(graph, 'pos'), with_labels=True)
    #
    # plt.show()


Se quita por que esto se va a controlar en el svg
# elarge = [(u, v) for (u, v, d) in votes.edges(data=True) if d['votes'] > draw_line]



def save_nodes_json(min_graph, weight_graph):
    stations = {}
    pos = weight_graph.nodes(data=True)
    for node in min_graph.nodes(data=True):
        stations[node[0]] = {}
        stations[node[0]]['label'] = node[0]
        stations[node[0]]['position'] = {}
        stations[node[0]]['position']['lat'] = pos._nodes[node[0]]['pos'][0]
        stations[node[0]]['position']['lng'] = pos._nodes[node[0]]['pos'][1]
    edge_list_min = list(min_graph.edges(data=True))
    print(edge_list_min)
    recorridos = np.zeros((edge_list_min.__len__(), edge_list_min.__len__()))
    #line 1
    lines_list = [{'name': 'Line1', 'label': 'Line1', 'color': '#FFD600', 'shiftCoords': [0, 0], 'nodes': []}]
    for edge in edge_list_min:
        if recorridos[int(edge[0])][int(edge[1])] == 0 or recorridos[int(edge[1])][int(edge[0])] == 0:
            recorridos[int(edge[0])][int(edge[1])] = 1
            lines_list[0]['nodes'].append({'name': edge[0],
                                       'coords': [pos._nodes[edge[0]]['pos'][0]*10000,pos._nodes[edge[0]]['pos'][1]*10000],
                                       'labelPos': 'S',
                                       'marker': 'interchange'})
            lines_list[0]['nodes'].append({'coords':[pos._nodes[edge[1]]['pos'][0]*10000,pos._nodes[edge[0]]['pos'][1]*10000]})
            lines_list[0]['nodes'].append({'name': edge[1],
                                       'coords': [pos._nodes[edge[1]]['pos'][0]*10000, pos._nodes[edge[1]]['pos'][1]*10000],
                                       'labelPos': 'S',
                                       'marker': 'interchange'})

    data = {'stations': stations, 'lines': lines_list}
    with open('./static/result.json', 'w') as fp:
        json.dump(data, fp)
    # print(data)
    return 0




    $("#submit").click(function () {
            //alert(markers[0].label);
            var number = $('#votes_number').val();
            console.log(number);
            $.ajax({
                type: 'post',
                    url: '/saveNumber',
                    data: $('#votes_number').val(),
            });
        });



function showMarkersDiv() {
            var summaryPanel = document.getElementById('directions');
            // summaryPanel.innerHTML = '';
            for (var i=0;i<markers.length;i++){
                summaryPanel.innerHTML += markers[i].label + ': ' + markers[i].position + '<br>';
            }
        }


function draw_route(){
            var start = markers[0].position;
            var end = markers[markers.length-1].position;
            var waypts = [];
            for (var i = 0; i < markers.length; i++){
                waypts.push(markers[i].position)
            }
            var dir=[];

           for (let i=1;i<markers.length-1;i++){
                dir.push({
                location: markers[i].position,
                stopover: false
              });
           }
            var request = {
                origin: start,
                destination: end,
                waypoints: dir,
                travelMode: 'WALKING'
            };
            directionsService.route(request, function(result, status) {
                if (status == 'OK') {
                    directionsRenderer.setDirections(result);
                }
            });
        }
        function calculateDistance(){
            var service = new google.maps.DistanceMatrixService();
            var originss = ["Perth, Australia", "Sydney, Australia"];
            var destinationss = ["Uluru, Australia", "Kakadu, Australia"];
            service.getDistanceMatrix(
                {
                    origins: originss,
                    destinations: destinationss,
                    travelMode: 'WALKING',
                    avoidHighways: true,
                    avoidTolls: true,
                }, callback);
        }
        function callback(response, status) {
            if (status == 'OK') {
                var origins = response.originAddresses;
                var destinations = response.destinationAddresses;

                for (var i = 0; i < origins.length; i++) {
                    var results = response.rows[i].elements;
                    for (var j = 0; j < results.length; j++) {
                        var element = results[j];
                        var distance = element.distance.text;
                        var duration = element.duration.text;
                        var from = origins[i];
                        var to = destinations[j];
                    }
                }
            }
        }



//////////LISTA JAVA SCRIPT

var myNodelist = document.getElementsByTagName("LI");
        var i;
        for (i = 0; i < myNodelist.length; i++) {
            var span = document.createElement("SPAN");
            var txt = document.createTextNode("\u00D7");
            span.className = "close";
            span.appendChild(txt);
            myNodelist[i].appendChild(span);
        }

        // Click on a close button to hide the current list item
        var close = document.getElementsByClassName("close");
        var i;
        for (i = 0; i < close.length; i++) {
            close[i].onclick = function() {
                var div = this.parentElement;
                div.style.display = "none";
            }
        }

        // Add a "checked" symbol when clicking on a list item
        var list = document.querySelector('ul');
        list.addEventListener('click', function(ev) {
            if (ev.target.tagName === 'LI') {
                ev.target.classList.toggle('checked');
            }
        }, false);

        // Create a new list item when clicking on the "Add" button
        function newElement(mark) {
            var li = document.createElement("li");
            var inputValue = mark;//document.getElementById("myInput").value;
            var t = document.createTextNode(inputValue);
            li.appendChild(t);
            if (inputValue === '') {
                alert("You must write something!");
            } else {
                document.getElementById("myUL").appendChild(li);
            }
            document.getElementById("myInput").value = "";

            var span = document.createElement("SPAN");
            var txt = document.createTextNode("\u00D7");
            span.className = "close";
            span.appendChild(txt);
            li.appendChild(span);

            for (i = 0; i < close.length; i++) {
                close[i].onclick = function() {
                    var div = this.parentElement;
                    div.style.display = "none";
                }
            }
        }
 HTML

<div class="col-md-4">
            <div id="myDIV" class="header">
                <h2>My To Do List</h2>
                <input type="text" id="myInput" placeholder="Title...">
                <span onclick="newElement()" class="addBtn">Add</span>
            </div>

            <ul id="myUL">


            </ul>
        </div>





Solapamiento de cuadrados (mío)

def calculate_overlap(text_weight, text_height, start, end, time_pos_negativa, time_pos_positiva):
    pm = [(start[0] + end[0]) / 2, (start[1] + end[1]) / 2]
    weight_rect = abs(end[0] - pm[0])
    height_rect = abs(end[1] - pm[1])

    list_rect_text = [Rect(Point(time_pos_negativa[0], time_pos_negativa[1]), text_weight, text_height),
                      Rect(Point(time_pos_negativa[0] - text_weight / 2, time_pos_negativa[1]), text_weight,
                           text_height),
                      Rect(Point(time_pos_negativa[0] - text_weight, time_pos_negativa[1]), text_weight, text_height),
                      Rect(Point(time_pos_negativa[0] - text_weight, time_pos_negativa[1] - text_height / 2),
                           text_weight,
                           text_height),
                      Rect(Point(time_pos_negativa[0] - text_weight, time_pos_negativa[1] - text_height), text_weight,
                           text_height),
                      Rect(Point(time_pos_negativa[0] - text_weight / 2, time_pos_negativa[1] - text_height),
                           text_weight,
                           text_height),
                      Rect(Point(time_pos_negativa[0], time_pos_negativa[1] - text_height), text_weight, text_height),
                      Rect(Point(time_pos_negativa[0], time_pos_negativa[1] - text_height / 2), text_weight,
                           text_height),
                      Rect(Point(time_pos_positiva[0], time_pos_positiva[1]), text_weight, text_height),
                      Rect(Point(time_pos_positiva[0] + text_weight / 2, time_pos_positiva[1]), text_weight,
                           text_height),
                      Rect(Point(time_pos_positiva[0] + text_weight, time_pos_positiva[1]), text_weight, text_height),
                      Rect(Point(time_pos_positiva[0] + text_weight, time_pos_positiva[1] + text_height / 2),
                           text_weight,
                           text_height),
                      Rect(Point(time_pos_positiva[0] + text_weight, time_pos_positiva[1] + text_height), text_weight,
                           text_height),
                      Rect(Point(time_pos_positiva[0] + text_weight / 2, time_pos_positiva[1] + text_height),
                           text_weight,
                           text_height),
                      Rect(Point(time_pos_positiva[0], time_pos_positiva[1] + text_height), text_weight, text_height),
                      Rect(Point(time_pos_positiva[0], time_pos_positiva[1] + text_height / 2), text_weight,
                           text_height)]

    rect_right_top = Rect(Point(pm[0], pm[1]), weight_rect, height_rect)
    rect_right_bottom = Rect(Point(pm[0], pm[1] - height_rect), weight_rect, height_rect)
    rect_left_top = Rect(Point(pm[0], pm[1] - height_rect), weight_rect, height_rect)
    rect_left_bottom = Rect(Point(pm[0] - weight_rect, pm[1] - height_rect), weight_rect, height_rect)
    list_rect = []
    if start[0] < end[0] and abs(end[1] - start[1]) > 0.004:  # izq derecha
        if end[1] < start[1]:  # sube
            list_rect.append(rect_left_bottom)
            list_rect.append(rect_right_top)
        else:
            list_rect.append(rect_left_top)
            list_rect.append(rect_right_bottom)
    elif start[0] > end[0] and abs(end[1] - start[1]) > 0.004:
        if end[1] < start[1]:  # sube
            list_rect.append(rect_right_bottom)
            list_rect.append(rect_left_top)
        else:
            list_rect.append(rect_right_bottom)
            list_rect.append(rect_right_top)
    else:
        return time_pos_negativa

    for rect_text in list_rect_text:
        for rect_line in list_rect:
            if not rect_text.collide(rect_line):
                return [rect_text.p.x, rect_text.p.y]

    return 0





function discretizar(lines) {
        text_height = 0.013;
        var points_list = [];
        for(var i=0;i<lines.length;i++){
            start = lines[i]['pos'][0];
            end = lines[i]['pos'][1];
            v_recta = {'x':start[0]-end[0], 'y':start[1]-end[1]};
            v_origen = {'x':start[0]-end[0], 'y':0};
            angulo = Math.acos(Math.abs(v_recta.x*v_origen.x+v_recta.y*v_origen.y)/(Math.sqrt(v_recta.x**2+v_recta.y**2)+Math.sqrt(v_origen.x**2+v_origen.y**2)));
            space = text_height * Math.cos(angulo);
            if(v_recta.x == 0.0){
                if(start[1] < end[1]){
                    origin = start[1];
                    final = end[1];
                }else {
                    origin = end[1];
                    final = start[1];
                }
                for(var j=origin;j<final; j+=space-0.003){
                    points_list.push({'x':start[0], 'y':j});
                    console.log('vertical');
                }
            }
            if (v_recta.y == 0.0){
                if(start[0] < end[0]){
                    origin = start[0];
                    final = end[0];
                }else{
                    origin = end[0];
                    final = start[0];
                }
                for(var x=origin;x<final; x+=space-0.003){
                    points_list.push({'x':x, 'y':start[1]});
                    console.log('horizontal');
                }
            }else {
                if(start[0] < end[0]){
                    origin = start[0];
                    final = end[0];
                }else{
                    origin = end[0];
                    final = start[0];
                }
                for(var x=origin;x<final; x+=space-0.003){
                    y = (((x-start[0])*v_recta.y) / v_recta.x) + start[1]
                    points_list.push({'x':x, 'y':y});
                    console.log('formula');
                }
            }
        }
        return points_list
    }


    -- svg to png
    /*$("#export").on("click", function() {
            var canvas = document.createElement("canvas");
            var ctx = canvas.getContext('2d');
            var svg = document.getElementById('svgout');
            var svg_widht = svg.getBBox().widht;
            var svg_height = svg.getBBox().height;
            ctx.clearRect(0, 0, svg_widht, svg_height);

            var DOMURL = window.URL || window.webkitURL || window;
            var img1 = new Image();
            var url = papers.toDataURL();
            img1.onload = function() {
                ctx.drawImage(img1, 0, 0);
                //var png = canvas.toDataURL("image/png");
                //var mg = document.createElement("img");
                //mg.setAttribute("src", png);
                //document.body.appendChild(mg);
                DOMURL.revokeObjectURL(url);
                var imgURI = canvas
                    .toDataURL("image/png")
                    .replace("image/png", "image/octet-stream");
                triggerDownload(imgURI, 'fileName.png');

            }
            img1.src = url;
            /*svg_xml = (new XMLSerializer()).serializeToString(document.getElementById('svgout'));
            var canvas = document.createElement("canvas");
            var ctx = canvas.getContext('2d');

            // this is just a JavaScript (HTML) image
            var img = new Image();
            // http://en.wikipedia.org/wiki/SVG#Native_support
            // https://developer.mozilla.org/en/DOM/window.btoa
            img.src = papers.toDataURL();

            img.onload = function() {
                // after this, Canvas’ origin-clean is DIRTY
                ctx.drawImage(img, 0, 0);
            };
            console.log(canvas.toDataURL("image/png"));
        });*/
